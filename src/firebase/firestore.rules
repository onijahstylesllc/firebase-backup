/**
  * @fileOverview
  * This ruleset enforces a strict user-ownership model for personal data and a role-based model for team data,
  * ensuring that users can only access their own resources, while teams manage their own members and roles.
  *
  * Data Structure:
  * - /users/{userId}: Stores individual user profiles. Only the authenticated user can access their own profile.
  * - /teams/{teamId}: Stores team information. Access is controlled by team membership.
  * - /users/{userId}/documents/{documentId}: Stores documents owned by a user. Only the owner can access.
  * - Subcollections under documents (aiMemoryThreads, aiMessages, tasks, documentVersions, comments) inherit ownership.
  * - /shareLinks/{shareLinkId}: Stores share links. Controlled by the creator.
  * - /fileFingerprints/{fileFingerprintId}: Stores file fingerprints. Controlled by the creator.
  * - /plugins/{pluginId}: Stores plugins. Controlled by the developer.
  * - /users/{userId}/usageCredit: Stores usage credit. Only the user can access their own usage credit.
  *
  * Key Security Decisions:
  * - User listing is disallowed to protect privacy.
  * - Data validation is relaxed for rapid prototyping but critical relational integrity checks are included (e.g., userId consistency).
  * - Top-level collections like `/shareLinks`, `/fileFingerprints`, and `/plugins` require careful authorization to prevent unauthorized access.
  * - Denormalization is used to determine access control.
  */
 

 rules_version = '2';
 service cloud.firestore {
  match /databases/{database}/documents {
 

   function isSignedIn() {
    return request.auth != null;
   }
 

   function isOwner(userId) {
    return isSignedIn() && request.auth.uid == userId;
   }
 

   function isExistingOwner(userId) {
    return isOwner(userId) && resource != null;
   }
 

   /**
    * @description Controls access to user profiles. Only the authenticated user can manage their own profile.
    * @path /users/{userId}
    * @allow (create) User A creates their profile with ID 'A'.
    * @deny (create) User B tries to create profile with ID 'A'.
    * @allow (get, update, delete) User A reads their profile with ID 'A'.
    * @deny (get, update, delete) User B tries to read User A's profile.
    * @principle Enforces document ownership for writes.
    */
   match /users/{userId} {
    allow get: if isOwner(userId);
    allow list: if false;
    allow create: if isOwner(userId) && request.resource.data.id == userId;
    allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
    allow delete: if isExistingOwner(userId);
   }
 

   /**
    * @description Controls access to team information.
    * @path /teams/{teamId}
    * @allow (create) Any authenticated user can create a team (for now).
    * @deny (update, delete) Non-team members cannot modify the team.
    * @principle For now, authenticated users can create teams. Later, team membership or admin roles should be incorporated.
    */
   match /teams/{teamId} {
    allow get: if true; // TODO: Implement team-based read access (e.g., team members)
    allow list: if true; // TODO: Implement team-based read access (e.g., team members)
    allow create: if isSignedIn();
    allow update: if false; // TODO: Implement team-based write access (e.g., team admins)
    allow delete: if false; // TODO: Implement team-based write access (e.g., team admins)
   }
 

   /**
    * @description Controls access to documents owned by a specific user.
    * @path /users/{userId}/documents/{documentId}
    * @allow (create) User A creates a document in their own /users/A/documents collection.
    * @deny (create) User B tries to create a document in /users/A/documents.
    * @allow (get, update, delete) User A reads/modifies a document in their own /users/A/documents collection.
    * @deny (get, update, delete) User B tries to read/modify a document in /users/A/documents.
    * @principle Enforces document ownership and restricts access to the owner.
    */
   match /users/{userId}/documents/{documentId} {
    allow get: if isOwner(userId);
    allow list: if isOwner(userId);
    allow create: if isOwner(userId) && request.resource.data.userId == userId;
    allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
    allow delete: if isExistingOwner(userId);
   }
 

   /**
    * @description Controls access to AI memory threads associated with a specific document.
    * @path /users/{userId}/documents/{documentId}/aiMemoryThreads/{aiMemoryThreadId}
    * @allow (create) User A creates a thread under their document.
    * @deny (create) User B tries to create a thread under User A's document.
    * @allow (get, update, delete) User A manages threads under their document.
    * @deny (get, update, delete) User B cannot manage threads under User A's document.
    * @principle Inherits ownership from the parent document.
    */
   match /users/{userId}/documents/{documentId}/aiMemoryThreads/{aiMemoryThreadId} {
    allow get: if isOwner(userId);
    allow list: if isOwner(userId);
    allow create: if isOwner(userId);
    allow update: if isExistingOwner(userId);
    allow delete: if isExistingOwner(userId);
   }
 

   /**
    * @description Controls access to AI messages within a specific AI memory thread.
    * @path /users/{userId}/documents/{documentId}/aiMemoryThreads/{aiMemoryThreadId}/aiMessages/{aiMessageId}
    * @allow (create) User A creates a message in their thread.
    * @deny (create) User B tries to create a message in User A's thread.
    * @allow (get, update, delete) User A manages messages in their thread.
    * @deny (get, update, delete) User B cannot manage messages in User A's thread.
    * @principle Inherits ownership from the parent AI memory thread and document.
    */
   match /users/{userId}/documents/{documentId}/aiMemoryThreads/{aiMemoryThreadId}/aiMessages/{aiMessageId} {
    allow get: if isOwner(userId);
    allow list: if isOwner(userId);
    allow create: if isOwner(userId);
    allow update: if isExistingOwner(userId);
    allow delete: if isExistingOwner(userId);
   }
 

   /**
    * @description Controls access to audit events associated with a specific user.
    * @path /users/{userId}/auditEvents/{auditEventId}
    * @allow (create)  User A can create audit event in their profile with ID 'A'.
    * @deny (create) User B tries to create audit event with ID 'A'.
    * @allow (get, update, delete) User A reads their audit events with ID 'A'.
    * @deny (get, update, delete) User B tries to read User A's audit events.
    * @principle Enforces document ownership for writes.
    */
   match /users/{userId}/auditEvents/{auditEventId} {
    allow get: if isOwner(userId);
    allow list: if isOwner(userId);
    allow create: if isOwner(userId);
    allow update: if isExistingOwner(userId);
    allow delete: if isExistingOwner(userId);
   }
 

   /**
    * @description Controls access to tasks associated with a specific document.
    * @path /users/{userId}/documents/{documentId}/tasks/{taskId}
    * @allow (create) User A creates a task under their document.
    * @deny (create) User B tries to create a task under User A's document.
    * @allow (get, update, delete) User A manages tasks under their document.
    * @deny (get, update, delete) User B cannot manage tasks under User A's document.
    * @principle Inherits ownership from the parent document.
    */
   match /users/{userId}/documents/{documentId}/tasks/{taskId} {
    allow get: if isOwner(userId);
    allow list: if isOwner(userId);
    allow create: if isOwner(userId);
    allow update: if isExistingOwner(userId);
    allow delete: if isExistingOwner(userId);
   }
 

   /**
    * @description Controls access to document versions for a specific document.
    * @path /users/{userId}/documents/{documentId}/documentVersions/{documentVersionId}
    * @allow (create) User A creates a document version under their document.
    * @deny (create) User B tries to create a document version under User A's document.
    * @allow (get, update, delete) User A manages document versions under their document.
    * @deny (get, update, delete) User B cannot manage document versions under User A's document.
    * @principle Inherits ownership from the parent document.
    */
   match /users/{userId}/documents/{documentId}/documentVersions/{documentVersionId} {
    allow get: if isOwner(userId);
    allow list: if isOwner(userId);
    allow create: if isOwner(userId);
    allow update: if isExistingOwner(userId);
    allow delete: if isExistingOwner(userId);
   }
 

   /**
    * @description Controls access to comments associated with a specific document.
    * @path /users/{userId}/documents/{documentId}/comments/{commentId}
    * @allow (create) User A creates a comment under their document.
    * @deny (create) User B tries to create a comment under User A's document.
    * @allow (get, update, delete) User A manages comments under their document.
    * @deny (get, update, delete) User B cannot manage comments under User A's document.
    * @principle Inherits ownership from the parent document.
    */
   match /users/{userId}/documents/{documentId}/comments/{commentId} {
    allow get: if isOwner(userId);
    allow list: if isOwner(userId);
    allow create: if isOwner(userId);
    allow update: if isExistingOwner(userId);
    allow delete: if isExistingOwner(userId);
   }
 

   /**
    * @description Controls access to share links.
    * @path /shareLinks/{shareLinkId}
    * @allow (create) Any authenticated user can create a share link (for now).
    * @deny (update, delete) Non-creators cannot modify the share link.
    * @principle For now, authenticated users can create share links. Later, creator ownership or admin roles should be incorporated.
    */
   match /shareLinks/{shareLinkId} {
    allow get: if true; // TODO: Implement read access (e.g., creator or link permissions)
    allow list: if true; // TODO: Implement read access (e.g., creator or link permissions)
    allow create: if isSignedIn();
    allow update: if false; // TODO: Implement write access (e.g., creator or admin roles)
    allow delete: if false; // TODO: Implement write access (e.g., creator or admin roles)
   }
 

   /**
    * @description Controls access to file fingerprints.
    * @path /fileFingerprints/{fileFingerprintId}
    * @allow (create) Any authenticated user can create a file fingerprint (for now).
    * @deny (update, delete) Non-creators cannot modify the file fingerprint.
    * @principle For now, authenticated users can create file fingerprints. Later, creator ownership or admin roles should be incorporated.
    */
   match /fileFingerprints/{fileFingerprintId} {
    allow get: if true; // TODO: Implement read access (e.g., creator or admin roles)
    allow list: if true; // TODO: Implement read access (e.g., creator or admin roles)
    allow create: if isSignedIn();
    allow update: if false; // TODO: Implement write access (e.g., creator or admin roles)
    allow delete: if false; // TODO: Implement write access (e.g., creator or admin roles)
   }
 

   /**
    * @description Controls access to UsageCredit balance for a specific user.
    * @path /users/{userId}/usageCredit
    * @allow (create)  User A can create UsageCredit in their profile with ID 'A'.
    * @deny (create) User B tries to create UsageCredit with ID 'A'.
    * @allow (get, update, delete) User A reads their UsageCredit with ID 'A'.
    * @deny (get, update, delete) User B tries to read User A's UsageCredit.
    * @principle Enforces document ownership for writes.
    */
   match /users/{userId}/usageCredit {
    allow get: if isOwner(userId);
    allow list: if false;
    allow create: if isOwner(userId) && request.resource.data.userId == userId;
    allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
    allow delete: if isExistingOwner(userId);
   }
 

   /**
    * @description Controls access to plugins.
    * @path /plugins/{pluginId}
    * @allow (create) Any authenticated user can create a plugin (for now).
    * @deny (update, delete) Non-developers cannot modify the plugin.
    * @principle For now, authenticated users can create plugins. Later, developer ownership or admin roles should be incorporated.
    */
   match /plugins/{pluginId} {
    allow get: if true; // TODO: Implement read access (e.g., developer or admin roles)
    allow list: if true; // TODO: Implement read access (e.g., developer or admin roles)
    allow create: if isSignedIn();
    allow update: if false; // TODO: Implement write access (e.g., developer or admin roles)
    allow delete: if false; // TODO: Implement write access (e.g., developer or admin roles)
   }
  }
 }